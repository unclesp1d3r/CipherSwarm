---
description: 
globs: 
alwaysApply: false
---
# SSR Migration Patterns and Best Practices

## Overview
This rule documents successful patterns and lessons learned from migrating CipherSwarm from SPA to SSR, including Formsnap integration, SvelteKit 5 runes, and form action implementation.

## Migration Status

### Completed Tasks ✅
- [x] **Dashboard Route** - SSR data loading with real-time stats
- [x] **Campaigns Routes** - List and detail pages with SSR + form actions
- [x] **Attacks Routes** - List page with complex attack wizard modal
- [x] **Projects Management** - SSR with project switching functionality  
- [x] **Users Management** - CRUD operations with role-based access
- [x] **Resources Management** - File upload, preview, and management
- [x] **Agents Dashboard** - Real-time monitoring with SSR initial data
- [x] **Settings Page** - Configuration management with form validation
- [x] **Form Migration** - All major forms converted to Superforms + actions

### Current Blocker ⚠️
- [ ] **SSR Authentication Flow** - Missing session handling for SSR load functions

## Established Patterns

### 1. SSR Load Function Pattern

**File Pattern**: `+page.server.ts` for every route requiring data

```typescript
import type { PageServerLoad } from './$types';
import { serverApi } from '$lib/server/api';
import { error } from '@sveltejs/kit';

export const load: PageServerLoad = async ({ cookies, params }) => {
    // Test environment detection
    if (process.env.NODE_ENV === 'test' || process.env.PLAYWRIGHT_TEST || process.env.CI) {
        return { campaigns: mockCampaignData };
    }
    
    try {
        const response = await serverApi.get(`/api/v1/web/campaigns/`, {
            headers: { 
                'Cookie': cookies.get('sessionid') || '',
                'X-Requested-With': 'XMLHttpRequest'
            }
        });
        
        return { campaigns: response.data };
    } catch (err) {
        if (err.response?.status === 401) {
            throw redirect(302, '/login');
        }
        throw error(500, 'Failed to load campaigns');
    }
};
```

### 2. SvelteKit 5 Runes Store Pattern

**Reference**: [campaigns store](mdc:CipherSwarm/frontend/src/lib/stores/campaigns.ts)

```typescript
import { writable } from 'svelte/store';

export function createCampaignsStore() {
    const campaigns = $state<Campaign[]>([]);
    const loading = $state(false);
    
    // Derived computed values
    const activeCampaigns = $derived(
        campaigns.filter(c => c.status === 'active')
    );
    
    // Hydrate from SSR data
    function hydrate(data: Campaign[]) {
        campaigns.splice(0, campaigns.length, ...data);
    }
    
    // Update after form actions
    function updateCampaign(updated: Campaign) {
        const index = campaigns.findIndex(c => c.id === updated.id);
        if (index >= 0) {
            campaigns[index] = updated;
        }
    }
    
    return {
        get campaigns() { return campaigns; },
        get activeCampaigns() { return activeCampaigns; },
        get loading() { return loading; },
        hydrate,
        updateCampaign
    };
}
```

### 3. Proper Formsnap Integration Pattern

**Critical Implementation** (see [attack wizard](mdc:CipherSwarm/frontend/src/routes/attacks/new/+page.svelte)):

```svelte
<script lang="ts">
import { Field, Control, Label, FieldErrors } from 'formsnap';
import { superForm } from 'sveltekit-superforms';
import { zodClient } from 'sveltekit-superforms/adapters';

export let data;

const { form, errors, enhance, submitting } = superForm(data.form, {
    validators: zodClient(attackSchema)
});
</script>

<!-- CORRECT Formsnap pattern with Svelte 5 snippets -->
<form method="POST" use:enhance>
    <Field {form} name="name">
        <Control>
            {#snippet children({ props })}
                <Label>Attack Name</Label>
                <Input {...props} bind:value={$form.name} />
            {/snippet}
        </Control>
        <FieldErrors />
    </Field>
</form>
```

**Key Requirements**:
- ✅ Use `{#snippet children({ props })}` (Svelte 5 syntax)
- ✅ Destructure `props` from snippet parameter
- ✅ Import from `'formsnap'` directly
- ❌ Never use basic HTML forms as shortcuts

### 4. Modal-to-Route Migration Pattern

**Pattern**: Convert modals to dedicated routes with modal presentation

**Example**: Campaign editor modal → `/campaigns/new` route

```svelte
<!-- +page.svelte -->
<script lang="ts">
import { goto } from '$app/navigation';
import { Modal } from '$lib/components/ui/modal';

export let data;

function handleClose() {
    goto('/campaigns', { invalidateAll: true });
}
</script>

<Modal open={true} onOpenChange={handleClose}>
    <form method="POST" use:enhance>
        <!-- Form content -->
    </form>
</Modal>
```

**Navigation Pattern**:
```svelte
<!-- In campaigns list -->
<Button href="/campaigns/new">New Campaign</Button>
<Button href="/campaigns/{campaign.id}/edit">Edit</Button>
```

### 5. Multi-Step Form Wizard Pattern

**Example**: [Attack creation wizard](mdc:CipherSwarm/frontend/src/routes/attacks/new/+page.svelte)

```svelte
<script lang="ts">
let currentStep = $state(0);
const steps = ['Basic Configuration', 'Attack Settings', 'Resources', 'Review'];

// Show fields based on current step and attack type
const showField = (field: string) => {
    const stepFields = {
        0: ['name', 'attack_mode', 'hash_type'],
        1: ['mask', 'increment_mode', 'increment_min'],
        2: ['wordlist_id', 'rule_list_id'],
        3: [] // Review step
    };
    return stepFields[currentStep]?.includes(field) ?? false;
};
</script>

<div class="wizard-container">
    {#each steps as step, index}
        <div class="step" class:active={index === currentStep}>
            {step}
        </div>
    {/each}
</div>

<!-- Conditional field rendering -->
{#if showField('name')}
    <Field {form} name="name">
        <!-- Field implementation -->
    </Field>
{/if}
```

## Critical Lessons Learned

### 1. Formsnap Implementation

**Issue**: Abandoning Formsnap for basic HTML when encountering integration issues
**Solution**: Always use proper Formsnap pattern with Svelte 5 snippets
**Rule**: Never shortcut to basic HTML - fix Formsnap integration instead

### 2. Environment Detection Strategy

**Pattern**: Consistent test environment detection
```typescript
if (process.env.NODE_ENV === 'test' || process.env.PLAYWRIGHT_TEST || process.env.CI) {
    return { mockData };
}
```

**Playwright Config**:
```typescript
webServer: {
    env: { PLAYWRIGHT_TEST: 'true' }
}
```

### 3. Docker Configuration Reuse

**Lesson**: Don't create new Docker setups - reuse existing working configurations
**Example**: Use `Dockerfile.dev` for E2E testing instead of modifying production Dockerfile
**Rule**: Check existing Docker files before creating new ones

### 4. Task Completion Discipline

**Critical Rule**: Complete one task fully before moving to next
**Anti-pattern**: Partial implementations across multiple routes
**Verification**: Run `just ci-check` only after completing logical groups

### 5. Component Data Flow Changes

**Before (SPA)**:
```svelte
<script>
import { onMount } from 'svelte';
let campaigns = [];

onMount(async () => {
    const response = await api.get('/campaigns');
    campaigns = response.data;
});
</script>
```

**After (SSR)**:
```svelte
<script>
export let data; // From +page.server.ts
$: campaigns = data.campaigns;
</script>
```

### 6. Store Hydration Pattern

**Example**: [Projects store hydration](mdc:CipherSwarm/frontend/src/lib/stores/projects.ts)
```typescript
// In +layout.server.ts or +page.server.ts
export const load = async () => {
    const projects = await getProjects();
    return { projects };
};

// In component
<script>
import { projectsStore } from '$lib/stores/projects';
export let data;

// Hydrate store from SSR data
$effect(() => {
    if (data.projects) {
        projectsStore.hydrate(data.projects);
    }
});
</script>
```

## Component Integration Patterns

### 1. Namespace Imports for Multi-Component Libraries

```typescript
// ✅ Correct pattern
import * as Accordion from '$lib/components/ui/accordion/index.js';
// Usage: <Accordion.Root><Accordion.Item>

// ❌ Avoid individual imports that may not exist
import { AccordionRoot } from '$lib/components/ui/accordion/root.js';
```

### 2. FileDropZone Integration

**Reference**: [Resource upload implementation](mdc:CipherSwarm/frontend/src/routes/resources/upload/+page.svelte)

```svelte
<script lang="ts">
import { FileDropZone } from '@ieedan/shadcn-svelte-extras';

function handleFilesSelected(files: File[]) {
    // Process uploaded files
}

function handleFileRejected({ reason, file }: { reason: string; file: File }) {
    // Handle rejection
}
</script>

<FileDropZone
    onUpload={handleFilesSelected}
    onFileRejected={handleFileRejected}
    accept=".txt,.csv,.json"
    maxSize={10 * 1024 * 1024}
/>
```

### 3. JSRepo Component Integration

**Pattern**: Use JSRepo for Shadcn-Svelte-Extras components
```bash
# Check available components
just jsrepo-list

# Get specific component
just jsrepo-get @ieedan/shadcn-svelte-extras/ts/file-drop-zone
```

## Error Handling Patterns

### 1. SSR Load Function Errors

```typescript
export const load: PageServerLoad = async ({ cookies }) => {
    try {
        const response = await serverApi.get('/api/v1/web/campaigns/');
        return { campaigns: response.data };
    } catch (err) {
        if (err.response?.status === 401) {
            throw redirect(302, '/login');
        }
        if (err.response?.status === 403) {
            throw error(403, 'Access denied');
        }
        throw error(500, 'Failed to load data');
    }
};
```

### 2. Form Action Error Handling

```typescript
export const actions: Actions = {
    default: async ({ request, cookies }) => {
        const form = await superValidate(request, zod(schema));
        
        if (!form.valid) {
            return fail(400, { form });
        }
        
        try {
            await serverApi.post('/api/v1/web/campaigns/', form.data);
            return redirect(303, '/campaigns');
        } catch (err) {
            return fail(500, { 
                form, 
                message: 'Creation failed' 
            });
        }
    }
};
```

## Current Implementation Status

### Successfully Migrated Components
- **Data Loading**: All routes use SSR load functions with proper error handling
- **Form Actions**: All forms use SvelteKit actions with Superforms + Zod validation
- **State Management**: SvelteKit 5 runes implemented throughout
- **Modal Conversion**: All modal forms converted to dedicated routes
- **Testing**: Three-tier architecture with Docker E2E infrastructure

### Ready for Authentication Implementation
The SSR migration is complete except for authentication. All patterns are established and working. The next step is implementing the SSR authentication flow documented in [ssr-authentication.mdc](mdc:CipherSwarm/.cursor/rules/CipherSwarm/frontend/ssr-authentication.mdc).

