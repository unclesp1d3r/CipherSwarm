---
description: 
globs: tests/**/*.py
alwaysApply: false
---

## Principles

- Use `pytest` only, no unittest or nose.
- Prefer fixtures over mocks when integrating components.
- All new service logic must have corresponding tests in `tests/services/`.
- Avoid integration tests in unit test directories.

## Cursor Guidance

- Use descriptive function names (`test_assign_agent_to_session_succeeds()`).
- Group related tests into modules that mirror `app/` structure.
- Use `@pytest.mark.asyncio` for async tests.
- Only import `from app.services.X` or `from app.models.X` â€” donâ€™t use relative imports.

- Minimum required test coverage: **80%**
- Use `pytest --cov=app --cov-report=term-missing` in all coverage reports
- Report coverage deltas in CI (or log locally if airgapped)

- âœ… Use `polyfactory` for generating test data in service, model, and route tests.
  - Define all factories in `tests/factories/`.
  - Reuse shared factories across test files.
  - Avoid manually constructing ORM or Pydantic objects in tests unless necessary.
  - Keep factory defaults minimal â€” override fields in tests as needed.

- âœ… Use `pytest-postgresql` to run tests against isolated PostgreSQL instances.
  - Do not use SQLite or in-memory DBs unless explicitly required.
  - Define shared test schemas and data fixtures in `conftest.py`.

- âœ… Use `httpx.AsyncClient` for testing FastAPI endpoints.
  - Instantiate as: `httpx.AsyncClient(app=app, base_url="http://test")`
  - Do not use Starletteâ€™s test client or custom wrappers.
  - Place route integration tests under `tests/api/` grouped by functional area.


---

## Test Directory Layout

- Unit tests go under `tests/`, mirroring the `app/` structure.
  - e.g., `tests/services/`, `tests/models/`, `tests/core/`
- Integration tests go under `tests/integration/`
  - Group by feature or API version
  - e.g., `tests/integration/campaigns/`, `tests/integration/v1/`

**Do not mix unit and integration tests.**

---

## Coverage Expectations

- All HTTP endpoints must have corresponding integration tests using `httpx.AsyncClient`.
- All business logic â€” especially services, validators, and helpers â€” must be covered with unit tests.
- Include tests for:
  - Non-happy paths (e.g., validation failures, auth failures)
  - State transitions (e.g., cracking lifecycle)
  - Expected side effects (e.g., DB writes, notifications)
- Tests should validate real-world workflows where possible, not just inputs/outputs.

Avoid over-mocking. Prioritize realistic, layered testing grounded in the real stack.

---

## Advanced Coverage Considerations

- ğŸŒ€ **Asynchronous Side Effects**: If a route or service spawns background tasks (e.g., via `asyncio.create_task` or Celery), write tests to confirm those tasks are queued, invoked, or cause expected state changes.

- âš”ï¸ **Concurrency & Race Conditions**: Simulate concurrent execution of relevant endpoints (e.g., task acquisition, job tracking) using `pytest-asyncio` with `asyncio.gather()` or `trio`. Verify consistent outcomes.

- ğŸ“¦ **Schema Drift & API Contracts**: Where endpoints return structured responses (e.g., JSON), add explicit schema validation using Pydantic models or response matchers to catch unintentional output changes.

- ğŸ” **RBAC & Permission Boundaries**: For protected routes or admin-only actions, include both authorized and unauthorized test cases. Validate HTTP 403 behavior and prevent privilege escalation.

- ğŸ” **Startup/Shutdown Events**: If your application registers services, event handlers, or startup hooks, write integration tests that validate those hooks fire and function as expected.

---

## Linter & Static Analysis Guidelines (for /tests)

You should attempt to satisfy all linter and static analysis rules in the `/tests` directory. However:

- Do **not** waste time chasing every false-positive caused by test-specific code structures (e.g., dynamically generated test IDs, parametrization, context-dependent mocks).
- If a linter rule fails for a **legitimate test use case**:
  - âœ… First, try to restructure the code to avoid the warning.
  - âœ… If thatâ€™s not possible, **ask permission** before adding a `# noqa` or updating `pyproject.toml` to silence the warning globally or selectively.
  - âŒ Never disable test directory linting wholesale.

Linter errors in tests should be treated as **soft failures** unless they indicate real issues (e.g., unimported fixtures, unreachable code, broken decorators). Prioritize clarity and functionality over silence.
