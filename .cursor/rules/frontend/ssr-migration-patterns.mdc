---
description: 
globs: 
alwaysApply: false
---
# SSR Migration Patterns and Best Practices

## Overview
This rule documents proven patterns for migrating SvelteKit applications from SPA to SSR, based on the comprehensive migration outlined in [spa_to_ssr.md](mdc:CipherSwarm/docs/v2_rewrite_implementation_plan/side_quests/spa_to_ssr.md).

## Data Loading Patterns

### SSR Data vs Store Data
- **Pages should use SSR data directly** when possible
- **Only hydrate stores when components need reactive updates**
- **Avoid mixing SSR data and store data in the same component**

```svelte
<!-- ✅ CORRECT - Use SSR data directly -->
<script lang="ts">
    export let data: PageData;
    
    let campaigns = $derived(data.campaigns.items);
    let totalCount = $derived(data.campaigns.total_count);
</script>

<!-- ❌ WRONG - Don't mix SSR data with store calls -->
<script lang="ts">
    export let data: PageData;
    import { getCampaigns } from '$lib/stores/campaigns.svelte';
    
    let campaigns = $derived(getCampaigns()); // This creates confusion
</script>
```

### Load Function Patterns
```typescript
// ✅ CORRECT - Robust load function with error handling
export const load: PageServerLoad = async ({ cookies, url, params }) => {
    // Environment detection for tests
    if (process.env.NODE_ENV === 'test' || process.env.PLAYWRIGHT_TEST) {
        return { campaigns: mockCampaignData };
    }
    
    try {
        const response = await serverApi.get('/api/v1/web/campaigns/', {
            headers: { Cookie: cookies.get('sessionid') || '' }
        });
        
        return {
            campaigns: response.data,
            meta: {
                title: 'Campaigns',
                description: 'Manage your password cracking campaigns'
            }
        };
    } catch (error) {
        if (error.response?.status === 401) {
            throw redirect(302, '/login');
        }
        throw error(500, 'Failed to load campaigns');
    }
};
```

## Store Hydration Patterns

### When to Hydrate Stores
- **Components need reactive updates** after initial SSR load
- **Real-time data updates** (polling, WebSocket updates)
- **Cross-component state sharing** is required

```typescript
// ✅ CORRECT - Hydrate only when reactive updates needed
$effect(() => {
    // Only hydrate if components will update this data
    if (needsReactiveUpdates) {
        campaignsStore.hydrateCampaigns(data.campaigns);
    }
});
```

### Store Hydration Implementation
```typescript
export const campaignsStore = {
    // Hydration method for SSR data
    hydrateCampaigns(ssrData: CampaignListResponse) {
        campaignState.campaigns = ssrData.items;
        campaignState.totalCount = ssrData.total_count;
        campaignState.page = ssrData.page;
        campaignState.loading = false;
    },
    
    // Reactive getters
    get campaigns() { return campaignState.campaigns; },
    get loading() { return campaignState.loading; }
};
```

## Testing Patterns

### Environment Detection
```typescript
// ✅ CORRECT - Comprehensive test environment detection
if (process.env.NODE_ENV === 'test' || 
    process.env.PLAYWRIGHT_TEST || 
    process.env.CI) {
    return { mockData };
}
```

### Playwright Configuration
```typescript
// playwright.config.ts
export default defineConfig({
    webServer: {
        command: 'pnpm run build && pnpm run preview',
        port: 4173,
        env: {
            PLAYWRIGHT_TEST: 'true' // Enable test environment detection
        }
    }
});
```

### Mock Data Consistency
```typescript
// ✅ CORRECT - Mock data matches API structure exactly
const mockCampaigns = {
    items: [
        {
            id: 1,
            name: 'Test Campaign',
            status: 'active' as const, // Use exact enum values
            created_at: '2024-01-01T00:00:00Z'
        }
    ],
    total_count: 1,
    page: 1,
    page_size: 10,
    total_pages: 1
};
```

## Form Migration Patterns

### Modal to Route Conversion
```typescript
// ✅ CORRECT - Convert modals to dedicated routes with modal presentation
// Route: /campaigns/new
// Triggered by: Button in campaigns list
// Presentation: Modal overlay using dialog component
// Form handling: Standard SvelteKit form actions

export const actions: Actions = {
    default: async ({ request, cookies }) => {
        const form = await superValidate(request, zod(campaignSchema));
        
        if (!form.valid) {
            return fail(400, { form });
        }
        
        // Convert form data to API format
        const apiPayload = convertCampaignData(form.data);
        
        try {
            const campaign = await serverApi.post('/api/v1/web/campaigns/', apiPayload);
            return redirect(303, `/campaigns/${campaign.id}`);
        } catch (error) {
            return fail(500, { form, message: 'Failed to create campaign' });
        }
    }
};
```

### Superforms Integration
```svelte
<script lang="ts">
    import { superForm } from 'sveltekit-superforms';
    import { zodClient } from 'sveltekit-superforms/adapters';
    
    export let data;
    
    const { form, errors, enhance, submitting } = superForm(data.form, {
        validators: zodClient(campaignSchema)
    });
</script>

<form method="POST" use:enhance>
    <!-- Form fields using Formsnap components -->
</form>
```

## Error Handling Patterns

### Load Function Error Handling
```typescript
export const load: PageServerLoad = async ({ cookies }) => {
    try {
        const response = await serverApi.get('/api/v1/web/campaigns/');
        return { campaigns: response.data };
    } catch (error) {
        // Handle specific error cases
        if (error.response?.status === 401) {
            throw redirect(302, '/login');
        }
        if (error.response?.status === 403) {
            throw error(403, 'Access denied');
        }
        
        // Log error and provide fallback
        console.error('Failed to load campaigns:', error);
        throw error(500, 'Failed to load campaigns');
    }
};
```

### Component Error Boundaries
```svelte
<script lang="ts">
    export let data: PageData;
    
    // Handle potential data issues gracefully
    let campaigns = $derived(data.campaigns?.items || []);
    let hasError = $derived(!data.campaigns);
</script>

{#if hasError}
    <div class="error-state">
        <p>Failed to load campaigns. Please try again.</p>
    </div>
{:else}
    <!-- Normal content -->
{/if}
```

## Performance Patterns

### Selective Store Usage
```svelte
<!-- ✅ CORRECT - Use SSR data for initial render, store for updates -->
<script lang="ts">
    export let data: PageData;
    import { campaignsStore } from '$lib/stores/campaigns.svelte';
    
    // Use SSR data for initial render
    let initialCampaigns = data.campaigns.items;
    
    // Use store data for reactive updates (if needed)
    let liveCampaigns = $derived(campaignsStore.campaigns);
    
    // Choose data source based on context
    let displayCampaigns = $derived(
        liveCampaigns.length > 0 ? liveCampaigns : initialCampaigns
    );
</script>
```

### Lazy Store Hydration
```typescript
// Only hydrate stores when actually needed
$effect(() => {
    if (needsRealTimeUpdates && !campaignsStore.isHydrated) {
        campaignsStore.hydrateCampaigns(data.campaigns);
    }
});
```

## Migration Verification

### Checklist for Route Migration
- [ ] `+page.server.ts` created with proper load function
- [ ] Environment detection implemented for tests
- [ ] Error handling covers auth, permissions, and server errors
- [ ] Component uses SSR data directly (not store calls)
- [ ] Store hydration only when reactive updates needed
- [ ] Tests updated to match SSR behavior
- [ ] Mock data matches API structure exactly

### Common Migration Issues
1. **Runtime errors from direct `$derived` exports** - Use store object pattern
2. **Test failures from SSR expectations** - Update test assertions
3. **Build errors from runes in `.ts` files** - Use `.svelte.ts` extensions
4. **Hydration mismatches** - Ensure SSR and client data consistency

## File References
- Migration plan: [spa_to_ssr.md](mdc:CipherSwarm/docs/v2_rewrite_implementation_plan/side_quests/spa_to_ssr.md)
- Store examples: [campaigns.svelte.ts](mdc:CipherSwarm/frontend/src/lib/stores/campaigns.svelte.ts)
- SSR load functions: [+page.server.ts](mdc:CipherSwarm/frontend/src/routes/campaigns/+page.server.ts)
- Component patterns: [+page.svelte](mdc:CipherSwarm/frontend/src/routes/campaigns/+page.svelte)

