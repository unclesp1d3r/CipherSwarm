---
description: 
globs: frontend/**/*
alwaysApply: false
---
# Frontend Testing Patterns and Best Practices

## Overview
This rule consolidates all frontend testing patterns for CipherSwarm's SvelteKit 5 application, covering unit testing with runes, SSR testing expectations, component testing, and Vitest configuration.

## Test Environment Setup and Configuration

### Environment Detection
```typescript
// ✅ CORRECT - Comprehensive test environment detection
if (process.env.NODE_ENV === 'test' || 
    process.env.PLAYWRIGHT_TEST || 
    process.env.CI) {
    return { mockData };
}
```

### Vitest Configuration
Configure Vitest for SvelteKit 5 components with proper test environment setup:

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
    plugins: [sveltekit()],
    test: {
        environment: 'jsdom',
        setupFiles: ['./src/lib/test-setup.ts'],
        globals: true,
        coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
            thresholds: {
                global: {
                    branches: 80,
                    functions: 80,
                    lines: 80,
                    statements: 80
                }
            }
        }
    }
});
```

## SvelteKit 5 Unit Testing Patterns

### Store Testing with Runes
```typescript
// ✅ CORRECT - Mock .svelte.ts store files
vi.mock('$lib/stores/campaigns.svelte', () => ({
    campaignsStore: {
        get campaigns() { return []; },
        get loading() { return false; },
        get error() { return null; },
        hydrateCampaigns: vi.fn(),
        getCampaigns: vi.fn()
    }
}));

// ❌ WRONG - Cannot test runes directly in .ts files
// Delete test files that try to test rune functionality directly
```

### Component Testing with SSR Data
```typescript
// ✅ CORRECT - Test components with mock SSR data structure
import type { PageData } from './$types';

const mockPageData: PageData = {
    campaigns: {
        items: [
            {
                id: 1,
                name: 'Test Campaign',
                status: 'active' as const, // Use exact enum values
                created_at: '2024-01-01T00:00:00Z',
                updated_at: '2024-01-01T00:00:00Z',
                description: 'Test description'
            }
        ],
        total_count: 1,
        page: 1,
        page_size: 10,
        total_pages: 1
    }
};

render(CampaignsList, { 
    props: { data: mockPageData } 
});
```

### Mock Data Consistency
```typescript
// ✅ CRITICAL - Mock data must match API structure exactly
const mockCampaigns = {
    items: [...], // Exact API response structure
    total_count: 1, // Use snake_case as API returns
    page: 1,
    page_size: 10,
    total_pages: 1
};

// ❌ WRONG - Mismatched structure causes test failures
const mockCampaigns = {
    data: [...], // API doesn't return 'data' wrapper
    totalCount: 1 // API uses snake_case, not camelCase
};
```

### Runtime Errors from Store Exports
```typescript
// ❌ PROBLEM - Direct $derived exports cause test failures
export const campaigns = $derived(campaignState.campaigns);

// ✅ SOLUTION - Use store object pattern or getter functions
export const campaignsStore = {
    get campaigns() { return campaignState.campaigns; }
};

// ✅ ALTERNATIVE - Use export function pattern
export function getCampaigns() {
    return campaignState.campaigns;
}
```

## SSR vs SPA Testing Patterns

### SSR Data vs Store Data
- **Pages should use SSR data directly** when possible
- **Only hydrate stores when components need reactive updates**
- **Avoid mixing SSR data and store data in the same component**

```svelte
<!-- ✅ CORRECT - Use SSR data directly -->
<script lang="ts">
    export let data: PageData;
    
    let campaigns = $derived(data.campaigns.items);
    let totalCount = $derived(data.campaigns.total_count);
</script>

<!-- ❌ WRONG - Don't mix SSR data with store calls -->
<script lang="ts">
    export let data: PageData;
    import { getCampaigns } from '$lib/stores/campaigns.svelte';
    
    let campaigns = $derived(getCampaigns()); // This creates confusion
</script>
```

### Load Function Testing Patterns
```typescript
// ✅ CORRECT - Robust load function with error handling
export const load: PageServerLoad = async ({ cookies, url, params }) => {
    // Environment detection for tests
    if (process.env.NODE_ENV === 'test' || process.env.PLAYWRIGHT_TEST) {
        return { campaigns: mockCampaignData };
    }
    
    try {
        const response = await serverApi.get('/api/v1/web/campaigns/', {
            headers: { Cookie: cookies.get('sessionid') || '' }
        });
        
        return {
            campaigns: response.data,
            meta: {
                title: 'Campaigns',
                description: 'Manage your password cracking campaigns'
            }
        };
    } catch (error) {
        if (error.response?.status === 401) {
            throw redirect(302, '/login');
        }
        throw error(500, 'Failed to load campaigns');
    }
};
```

### Store Hydration Testing
```typescript
// ✅ CORRECT - Test store hydration when reactive updates needed
$effect(() => {
    // Only hydrate if components will update this data
    if (needsReactiveUpdates) {
        campaignsStore.hydrateCampaigns(data.campaigns);
    }
});
```

## Component Testing Best Practices

### Test Structure and Organization
```typescript
// ✅ CORRECT - Comprehensive component test structure
import { render, screen } from '@testing-library/svelte';
import { expect, test, vi } from 'vitest';
import CampaignCard from './CampaignCard.svelte';

test('displays campaign information correctly', () => {
    const mockCampaign = {
        id: 1,
        name: 'Test Campaign',
        status: 'active' as const,
        progress: 75,
        created_at: '2024-01-01T00:00:00Z'
    };

    render(CampaignCard, { props: { campaign: mockCampaign } });

    expect(screen.getByText('Test Campaign')).toBeInTheDocument();
    expect(screen.getByText('Active')).toBeInTheDocument();
    expect(screen.getByText('75%')).toBeInTheDocument();
});
```

### Form Testing with Superforms
```typescript
// ✅ CORRECT - Test form components with proper mock setup
import { superForm } from 'sveltekit-superforms';
import { zodClient } from 'sveltekit-superforms/adapters';

vi.mock('sveltekit-superforms', () => ({
    superForm: vi.fn(() => ({
        form: { subscribe: vi.fn() },
        errors: { subscribe: vi.fn() },
        enhance: vi.fn(),
        submitting: { subscribe: vi.fn() },
        delayed: { subscribe: vi.fn() },
        timeout: { subscribe: vi.fn() }
    }))
}));

test('form renders with correct fields', () => {
    const mockFormData = {
        name: '',
        description: '',
        project_id: null
    };

    render(CampaignForm, { props: { data: { form: mockFormData } } });
    
    expect(screen.getByLabelText('Campaign Name')).toBeInTheDocument();
    expect(screen.getByLabelText('Description')).toBeInTheDocument();
});
```

### Event Handling Testing
```typescript
// ✅ CORRECT - Test component events and interactions
import { fireEvent } from '@testing-library/svelte';

test('emits delete event when delete button clicked', async () => {
    const component = render(CampaignCard, { 
        props: { campaign: mockCampaign } 
    });

    const deleteButton = screen.getByText('Delete');
    await fireEvent.click(deleteButton);

    // Test that the component emitted the expected event
    expect(component.component.$capture_state().onDelete).toHaveBeenCalledWith(1);
});
```

## Store Testing Patterns

### Store Hydration Implementation Testing
```typescript
// ✅ CORRECT - Test store hydration methods with proper runes pattern
let campaignState = $state({
    campaigns: [],
    totalCount: 0,
    page: 1,
    loading: true
});

export const campaignsStore = {
    // Hydration method for SSR data
    hydrateCampaigns(ssrData: CampaignListResponse) {
        campaignState.campaigns = ssrData.items;
        campaignState.totalCount = ssrData.total_count;
        campaignState.page = ssrData.page;
        campaignState.loading = false;
    },
    
    // Reactive getters
    get campaigns() { return campaignState.campaigns; },
    get loading() { return campaignState.loading; },
    get totalCount() { return campaignState.totalCount; }
};

// Test the hydration method
test('hydrateCampaigns updates store state correctly', () => {
    const mockData = {
        items: [{ id: 1, name: 'Test Campaign' }],
        total_count: 1,
        page: 1,
        page_size: 10,
        total_pages: 1
    };

    campaignsStore.hydrateCampaigns(mockData);
    
    expect(campaignsStore.campaigns).toEqual(mockData.items);
    expect(campaignsStore.loading).toBe(false);
    expect(campaignsStore.totalCount).toBe(1);
});
```

### When to Hydrate Stores
- **Components need reactive updates** after initial SSR load
- **Real-time data updates** (polling, WebSocket updates)
- **Cross-component state sharing** is required

```typescript
// ✅ CORRECT - Hydrate only when reactive updates needed
$effect(() => {
    // Only hydrate if components will update this data
    if (needsReactiveUpdates) {
        campaignsStore.hydrateCampaigns(data.campaigns);
    }
});
```

## Error Handling Testing

### Load Function Error Testing
```typescript
// ✅ CORRECT - Test error handling in load functions
import { redirect, error } from '@sveltejs/kit';

test('load function handles 401 errors with redirect', async () => {
    const mockError = { response: { status: 401 } };
    vi.mocked(serverApi.get).mockRejectedValue(mockError);

    // Test that redirect is thrown
    await expect(load({ cookies: mockCookies, url: new URL('http://localhost'), params: {} }))
        .rejects.toEqual(redirect(302, '/login'));
});

test('load function handles 500 errors gracefully', async () => {
    const mockError = { response: { status: 500 } };
    vi.mocked(serverApi.get).mockRejectedValue(mockError);

    // Test that error is thrown
    await expect(load({ cookies: mockCookies, url: new URL('http://localhost'), params: {} }))
        .rejects.toEqual(error(500, 'Failed to load campaigns'));
});
```

### Component Error State Testing
```typescript
// ✅ CORRECT - Test component error states
test('displays error message when data loading fails', () => {
    const mockPageData = {
        campaigns: null,
        error: 'Failed to load campaigns'
    };

    render(CampaignsList, { props: { data: mockPageData } });
    
    expect(screen.getByText('Failed to load campaigns')).toBeInTheDocument();
    expect(screen.queryByText('Test Campaign')).not.toBeInTheDocument();
});
```

## Form Migration and Testing Patterns

### Modal to Route Testing
```typescript
// ✅ CORRECT - Test route-based modals with proper navigation
test('campaign creation modal opens from campaigns list', async () => {
    render(CampaignsList, { props: { data: mockPageData } });
    
    const createButton = screen.getByText('Create Campaign');
    await fireEvent.click(createButton);
    
    // Test navigation to modal route
    expect(mockNavigate).toHaveBeenCalledWith('/campaigns/new');
});
```

### Superforms Integration Testing
```typescript
// ✅ CORRECT - Test superforms with proper validation
test('form validates required fields', async () => {
    const { container } = render(CampaignForm, { 
        props: { data: { form: mockFormData } } 
    });
    
    const submitButton = screen.getByText('Create Campaign');
    await fireEvent.click(submitButton);
    
    expect(screen.getByText('Name is required')).toBeInTheDocument();
});
```

## Test Command Patterns and Workflow

### Development Testing Commands
```bash
# ✅ Fast iteration during development
pnpm exec vitest run                    # Unit tests only
pnpm exec vitest run --watch           # Watch mode for development

# ✅ Component-specific testing
pnpm exec vitest run src/lib/components/campaigns/
pnpm exec vitest run src/routes/campaigns/
```

### Verification Testing Commands
```bash
# ✅ Frontend-specific verification
just frontend-check        # Unit tests + linting
just frontend-lint         # Linting only

# ✅ Coverage reporting
pnpm exec vitest run --coverage
```

## Common Testing Issues and Solutions

### Import and Module Issues
```typescript
// ✅ CORRECT - Proper SvelteKit imports in tests
import { page } from '$app/state'; // Not $app/stores in Svelte 5
import { goto } from '$app/navigation';
import { browser } from '$app/environment';

// Mock SvelteKit modules properly
vi.mock('$app/navigation', () => ({
    goto: vi.fn()
}));
```

### Component Lifecycle Testing
```typescript
// ✅ CORRECT - Test component lifecycle with proper cleanup
import { cleanup } from '@testing-library/svelte';

afterEach(() => {
    cleanup();
    vi.clearAllMocks();
});
```

### Async Component Testing
```typescript
// ✅ CORRECT - Handle async operations in components
test('loads data asynchronously', async () => {
    const promise = Promise.resolve(mockData);
    vi.mocked(fetchData).mockReturnValue(promise);
    
    render(AsyncComponent);
    
    // Wait for async operations to complete
    await promise;
    
    expect(screen.getByText('Data loaded')).toBeInTheDocument();
});
```

## Coverage Requirements and Standards

### Unit Test Coverage
- **Target Coverage**: 80%+ for all critical components
- **Focus Areas**: 
  - Component rendering with various props
  - Event handling and user interactions
  - Store integration and state management
  - Form validation and submission
  - Error states and edge cases

### Test Quality Standards
- Use descriptive test names that explain the scenario
- Test behavior, not implementation details
- Mock external dependencies appropriately
- Clean up after each test
- Use proper assertions and matchers

### Testing Best Practices
- **Arrange-Act-Assert pattern**: Structure tests clearly
- **Single responsibility**: Each test should verify one behavior
- **Deterministic tests**: Avoid flaky tests with proper mocking
- **Readable tests**: Use clear naming and comments when needed

## Integration with Backend Testing

### API Mock Consistency
- Frontend mocks must match backend API responses exactly
- Use the same data structures and field names
- Maintain consistency between test environments
- Validate mock data against actual API schemas when possible

### Test Data Management
- Use consistent test data across frontend and backend
- Share common test utilities where appropriate
- Ensure mock data reflects real-world scenarios
- Update mocks when API contracts change







