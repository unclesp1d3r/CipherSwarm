# frozen_string_literal: false
# Nginx reverse proxy configuration for CipherSwarm production load balancing.
#
# REASONING:
#   Why: A single web instance becomes a bottleneck when many cracking agents
#        send concurrent status updates. Nginx distributes requests across
#        multiple Thruster/Puma replicas using Docker DNS service discovery.
#   Alternatives considered: HAProxy (heavier), Traefik (more complex config),
#        Docker Swarm ingress (requires Swarm mode).
#   Decision: Nginx is lightweight, well-understood, and works with plain
#        Docker Compose scaling via the embedded DNS resolver.
#   Performance: least_conn algorithm ensures even distribution under load;
#        keepalive connections reduce TCP overhead between nginx and backends.

worker_processes auto;

error_log /dev/stderr warn;
pid       /tmp/nginx.pid;

events {
    worker_connections 1024;
}

http {
    # Docker embedded DNS resolver for dynamic upstream resolution.
    resolver 127.0.0.11 valid=10s ipv6=off;

    access_log /dev/stdout;

    # Upstream pool targeting the scaled 'web' service.
    # Docker DNS resolves 'web' to all replica container IPs.
    upstream web_backend {
        least_conn;

        # 'resolve' re-queries DNS so new/removed replicas are picked up
        # automatically. max_fails / fail_timeout control passive health checks.
        server web:80 resolve max_fails=3 fail_timeout=30s;

        # Keep persistent connections to backends for efficiency.
        keepalive 32;
    }

    server {
        listen 80;

        # Allow large file uploads (hash lists, word lists, rule files).
        client_max_body_size 100M;

        # Gzip compression for text-based responses.
        gzip on;
        gzip_types text/plain text/css application/json application/javascript
                   text/xml application/xml application/xml+rss text/javascript
                   image/svg+xml;
        gzip_min_length 256;
        gzip_vary on;

        location / {
            proxy_pass http://web_backend;

            # Use HTTP/1.1 with empty Connection header for keepalive.
            proxy_http_version 1.1;
            proxy_set_header Connection "";

            # Preserve client information for Rails request handling.
            proxy_set_header Host              $host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host  $host;

            # Timeouts â€” read is longer for potentially slow API responses.
            proxy_connect_timeout 60s;
            proxy_send_timeout    60s;
            proxy_read_timeout    300s;

            # Retry the next upstream on transient errors.
            proxy_next_upstream error timeout http_502 http_503 http_504;
            proxy_next_upstream_tries 3;
        }
    }
}
